name: .NET Release
env:
  NUGET_SERVER_URL: "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json"
  GH_TOKEN: ${{ secrets.LATENCY_PAT }}
  
defaults:
  run:
    shell: powershell
   #shell: '"C:\\Program Files\\Git\\bin\\bash.exe" -eo pipefail -c'
   
on:
  push:
    tags: 'v[0-9]+.[0-9]+.[0-9]+(-preview)?'
    
  workflow_dispatch:
  
jobs:
  pre_job:
    runs-on: ubuntu-latest
    outputs:
      should_skip: ${{ steps.skip_check.outputs.should_skip }}
    steps:
      - id: skip_check
        uses: fkirc/skip-duplicate-actions@v5.3.1
        with:
          skip_after_successful_duplicate: 'true'
          
  release:
    needs: pre_job
    if: ${{ needs.pre_job.outputs.should_skip != 'true' }}
    runs-on: ${{ matrix.os }}
    
    permissions:
      packages: write
      contents: write      # write permission is required to create a github release
      pull-requests: write # write permission is required for autolabeler otherwise, read permission is required at least
      
    strategy:
        matrix:
            os: [self-hosted] #, ubuntu-latest, windows-latest]
            BuildConfiguration: [ Release ]
        max-parallel: 2
      
    steps:
       
    - name: Get PROJECT_NAME
      id: project-name
      run: |
        # Read environment variables
        $runnerOs = $env:RUNNER_OS
        Write-Host "runnerOS: $runnerOs"
        
        $githubRepository = $env:GITHUB_REPOSITORY
        Write-Host "githubRepository: $githubRepository"
        
        $githubEnvPath = $env:GITHUB_ENV
        Write-Host "githubEnvPath: $githubEnvPath"
        
        # Basic validation
        if ([string]::IsNullOrEmpty($runnerOs)) {
            Write-Error "Environment variable `RUNNER_OS` is not set."
            exit 1
        }
        if ([string]::IsNullOrEmpty($githubRepository)) {
            Write-Error "Environment variable `GITHUB_REPOSITORY` is not set."
            exit 1
        }
        
        # Split repository string into components depending on OS
        switch ($runnerOs.ToLower()) {
            'linux' {
                # Split on forward slash
                $split = $githubRepository -split '/'
            }
            'windows' {
                # Split on both forward and back slashes (robust against both styles)
                # Equivalent to splitting on regex [\/\ \]
                $split = $githubRepository -split '[\\/]' 
            }
            default {
                Write-Error "`$RUNNER_OS ($runnerOs) not supported"
                exit 1
            }
        }
        
        # Show the split components (joined for compactness)
        Write-Host "Split components: $($split -join ' ')"
        
        # Compute index of last element and get project tag
        if ($split.Count -eq 0) {
            Write-Error "Repository string `$GITHUB_REPOSITORY` did not produce any split components."
            exit 1
        }
        $index = $split.Count - 1
        $project_tag = $split[$index]
        
        # Output the project tag
        Write-Host "Project tag (last component): $project_tag"
        
        # Ensure we have a destination for GITHUB_ENV. If not provided, create a fallback file in workspace.
        if ([string]::IsNullOrEmpty($githubEnvPath)) {
            $fallbackPath = Join-Path -Path (Get-Location) -ChildPath "GITHUB_ENV"
            Write-Warning "Environment variable `GITHUB_ENV` is not set. Falling back to `\$PWD/GITHUB_ENV` ($fallbackPath)."
            $githubEnvPath = $fallbackPath
        }
        
        # Append PROJECT_NAME line to the GITHUB_ENV file (ensures file exists)
        try {
            $line = "PROJECT_NAME=$project_tag"
            # Use Add-Content which will create the file if it doesn't exist
            Add-Content -Path $githubEnvPath -Value $line -Encoding UTF8
            Write-Host "Appended to `GITHUB_ENV` - $line"
        } catch {
            Write-Error "Failed to write to `GITHUB_ENV` - File at path '$githubEnvPath'. Error: $_"
            exit 1
        }      
        
    - name: Get README.md Description & PACKAGE_VERSION
      id: readme-desc
      run: |
        # Validate environment
        
        $runnerOs = $env:RUNNER_OS
        if (-not $runnerOs) {
            Write-Error "RUNNER_OS is not set."
            exit 1
        } else {
          Write-Host "runnerOS:    '$runnerOs'"       
        }

        $workspace = $env:GITHUB_WORKSPACE
        if (-not $workspace) {
            Write-Error "GITHUB_WORKSPACE is not set."
            exit 1
        } else {
           Write-Host "workspace:   '$workspace'"
        }
        
        # Normalize workspace path on Windows (replace forward slashes with backslashes)
        switch ($runnerOs.ToLower()) {
            "linux" {
                # Keep as-is
            }
            "windows" {
                $workspace = $workspace -replace '/', '\'
            }
            default {
                Write-Error "$runnerOs not supported"
                exit 1
            }
        }
        
        # Collect filenames (only files) in the workspace
        try {
            $filenames = Get-ChildItem -Path $workspace -File -Name -ErrorAction Stop
        } catch {
            Write-Error "Failed to list files in workspace '$workspace': $_"
            exit 1
        }
        
        foreach ($filename in $filenames) {
            # Equivalent to: if [ -f $filename -a "$filename" = "README.md" ]; then
            if ($filename -eq 'README.md') {
                $filePath = Join-Path -Path $workspace -ChildPath $filename
        
                if (-not (Test-Path -Path $filePath -PathType Leaf)) {
                    # Not a regular file, skip
                    continue
                }
        
                # Read the second line (PowerShell arrays are 0-indexed)
                try {
                    $lines = Get-Content -Path $filePath -TotalCount 2 -ErrorAction Stop
                } catch {
                    Write-Error "Failed to read file '$filePath': $_"
                    continue
                }
        
                if ($lines.Count -ge 2) {
                    $secondLine = $lines[1]
                } elseif ($lines.Count -eq 1) {
                    # If only one line exists, fallback to that line (mirrors cautious behavior)
                    $secondLine = $lines[0]
                } else {
                    $secondLine = ""
                }
        
                # Remove carriage returns / line feeds (Get-Content typically strips newline, but TrimEnd for safety)
                $desc = $secondLine.TrimEnd("`r","`n")

                # Output and persist to GITHUB_ENV if available
                Write-Output "Description: '$desc'"
                if ($env:GITHUB_ENV) {
                    Add-Content -Path $env:GITHUB_ENV -Value "README_DESC=$desc"
                } else {
                    Write-Output "GITHUB_ENV is not set; skipping writing 'README_DESC' to env file."
                }
        
                # Extract package version from comment: <!-- VERSION: X -->
                # Use regex capture to get the inner value
                $package_version = ""
                try {
                    $match = Select-String -Path $filePath -Pattern '<!-- VERSION: (.*?) -->' -AllMatches -ErrorAction Stop
                } catch {
                    $match = $null
                }
        
                if ($match -and $match.Count -gt 0) {
                    $m = $match[0].Matches[0]
                    if ($m.Groups.Count -ge 2) {
                        $package_version = $m.Groups[1].Value.Trim()
                    }
                }
        
                Write-Output "Version:     '$package_version'"
                if ($env:GITHUB_ENV) {
                    Add-Content -Path $env:GITHUB_ENV -Value "PACKAGE_VERSION=$package_version"
                } else {
                    Write-Output "GITHUB_ENV is not set; skipping writing 'PACKAGE_VERSION' to env file."
                }
        
                # Found README.md and processed it â€” match original script's 'break'
                break
            }
        }

    - name: Authentication
      run: |
        # Verify authentication
        & gh auth status
      
    - name: Query Release (if exists)
      run: |
        # Set version from environment variable
        $version = "v$env:PACKAGE_VERSION"
        Write-Host "version: '$version'"
           
        # Change to src directory
        $currentLocation = Get-Location
        Write-Host "currentLocation: '$currentLocation'"
        
        # Get a list of all the releases
        $releases = (gh release list --json tagName --jq '.[] |.tagName')

        # Find if the version already exists within releases
        if ($releases -contains "$version") {
            Write-Output "Release '$version' was found."
            if ($env:GITHUB_ENV) {
                Write-Output "RELEASE_FOUND=true" | Out-File -FilePath $env:GITHUB_ENV -Append
            } else {
                Write-Output "GITHUB_ENV is not set; skipping writing 'RELEASE_FOUND' to env file."
            }
        } else {
            Write-Output "No release exists with version '$version'"
            if ($env:GITHUB_ENV) {
                Write-Output "RELEASE_FOUND=false" | Out-File -FilePath $env:GITHUB_ENV -Append
            } else {
                Write-Output "GITHUB_ENV is not set; skipping writing 'RELEASE_FOUND' to env file."
            }
        }

    - name: Delete Release
      if: ${{ env.RELEASE_FOUND == 'true' }} 
      run: |     
        Write-Host "Deleting current release 'v$env:PACKAGE_VERSION'"
        try {
          & gh release delete "v$env:PACKAGE_VERSION" --cleanup-tag
        } catch {
        }
  
    - name: Create Release
      run: |
        $draft = $false
        $preRelease = if ($env:PACKAGE_VERSION -match '-preview') { $true } else { $false }

        $body = @"
        $($env:README_DESC)
        $($env:GITHUB_RELEASE_CHANGELOG)
        "@
        
        $d = if ($draft -eq $true) { "-d " } else { "" }
        $p = if ($preRelease -eq $true) { "-p " } else { "" }
        
        & gh release create v$env:PACKAGE_VERSION $p$d--generate-notes --latest --title "$env:PROJECT_NAME" --notes "$body"

    - uses: NuGet/setup-nuget@v2.0.1
        
    - name: Check If NuGet Package Exists
      id: locate-package
      run: |
        # Write initial output 
        if ($env:GITHUB_ENV) {
            "NUGET_EXISTS=false" | Out-File -FilePath $env:GITHUB_ENV -Append
        } else {
            Write-Output "GITHUB_ENV is not set; skipping writing 'NUGET_EXISTS' to env file."
        } 

        # Search for the NuGet package
        $array = (nuget search $env:PROJECT_NAME -Source "github" | Select-String -Pattern "No results found\.|^>")
        Write-Host "Nuget Search: $array"
        
        if ($array -ne "No results found.") {
            # Extract package name and version
            $ary = $array | Where-Object { $_ -match '^> ' } | ForEach-Object {
                $line = $_ -replace '^> ', ''
                $parts = $line -split '\s+'
                $parts[0]  # name
                $parts[2]  # version (assuming version is the 3rd part)
            }
        
            $releaseName = $ary[0]
            Write-Host "ReleaseName: $releaseName vs ProjectName: $env:PROJECT_NAME"
            $releaseVersion = $ary[1]
            Write-Host "ReleaseVersion: $releaseVersion vs PackageVersion: $env:PACKAGE_VERSION"
        
            if ($releaseName -eq $env:PROJECT_NAME -and $releaseVersion -eq $env:PACKAGE_VERSION) {
                Write-Host "Package '$env:PROJECT_NAME.$env:PACKAGE_VERSION.nupkg' was found to exist."
                "NUGET_EXISTS=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
            }
        }

    - name: Remove Existing NuGet Package
      if: ${{ steps.locate-package.outputs.NUGET_EXISTS == 'true' }}
      #run: dotnet nuget delete ${{ env.PROJECT_NAME }} ${{ env.PACKAGE_VERSION }} --api-key ${{ secrets.NUGET_AUTH_TOKEN }} --non-interactive
      uses: actions/delete-package-versions@v5.0.0
      with: 
        owner: ${{ github.repository_owner }}
        package-name: ${{ env.PROJECT_NAME }}
        package-type: 'nuget'
        token: ${{ secrets.NUGET_AUTH_TOKEN }}

    - name: Push package to GitHub packages  
      run: |
        Write-Host "dotnet nuget push `"D:\Source\Packages\$env:PROJECT_NAME.$env:PACKAGE_VERSION.nupkg`" -n --skip-duplicate -k ${{ secrets.NUGET_AUTH_TOKEN }}"
        dotnet nuget push "D:\Source\Packages\$env:PROJECT_NAME.$env:PACKAGE_VERSION.nupkg" -n --skip-duplicate -k ${{ secrets.NUGET_AUTH_TOKEN }}
